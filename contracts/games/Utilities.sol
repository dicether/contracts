pragma solidity ^0.8.11;

import "../SafeMath.sol";
import "../SafeCast.sol";


contract Utilities {
    using SafeCast for int;
    using SafeCast for uint;
    using SafeMath for int;
    using SafeMath for uint;

    uint constant public PROBABILITY_DIVISOR = 10000;
    uint constant public HOUSE_EDGE = 150;
    uint constant public HOUSE_EDGE_DIVISOR = 10000;

    /**
     * @dev Calc max bet we allow
     * We definitely do not allow bets greater than kelly criterion would allow.
     * => The max bet is limited to the max profit of houseEdge * bankroll.
     * => maxBet = houseEdge / (1/p * (1 - houseEdge) - 1) * bankroll, with p is win probability.
     * The max bet can be further restricted on backend.
     * @param _winProbability winProbability.
     * @return max allowed bet.
     */
    function maxBetFromProbability(uint _winProbability, uint _bankRoll) public pure returns(uint) {
        assert(0 < _winProbability && _winProbability < PROBABILITY_DIVISOR);

        uint tmp1 = PROBABILITY_DIVISOR.mul(HOUSE_EDGE_DIVISOR).div(_winProbability);
        uint tmp2 = PROBABILITY_DIVISOR.mul(HOUSE_EDGE).div(_winProbability);

        uint enumerator = HOUSE_EDGE.mul(_bankRoll);
        uint denominator = tmp1.sub(tmp2).sub(HOUSE_EDGE_DIVISOR);
        return enumerator.div(denominator);
    }

    /**
     * Calculate user profit from total won.
     * @param _totalWon user winnings.
     * @param _betValue bet value.
     * @return user profit.
     */
    function calcProfitFromTotalWon(uint _totalWon, uint _betValue) public pure returns(int) {
        uint houseEdgeValue = _totalWon.mul(HOUSE_EDGE).div(HOUSE_EDGE_DIVISOR);

        return _totalWon.castToInt().sub(houseEdgeValue.castToInt()).sub(_betValue.castToInt());
    }

    /**
     * @dev Generates a 256 bit random number by combining server and user seed.
     * @param _serverSeed server seed.
     * @param _userSeed user seed.
     * @return random number generated by combining server and user seed.
     */
    function generateRandomNumber(bytes32 _serverSeed, bytes32 _userSeed) public pure returns(uint) {
        bytes32 combinedHash = keccak256(abi.encodePacked(_serverSeed, _userSeed));
        return uint(combinedHash);
    }
}
